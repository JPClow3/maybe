---
description: High-level conventions for writing code in the Maybe Django codebase
globs: maybe_django/**/*
alwaysApply: true
---
This rule serves as high-level documentation for how you should write code for the Maybe codebase. 

## Project Tech Stack

- Web framework: Django 5.0+
  - Django unittest for testing
  - Django templates for server-side rendering
  - HTMX for SPA-like UI/UX
  - django-components for reusable UI components
  - TailwindCSS v3.4+ for styles (built via PostCSS with custom design system)
- Database: PostgreSQL
- Jobs: Celery + Redis
- External
  - B3 investment data: yfinance for Brazilian stock market
  - OFX parsing: ofxparse for bank file imports
  - CSV parsing: pandas for data processing

## Project conventions

These conventions should be used when writing code for Maybe.

### Convention 1: Minimize dependencies, vanilla Django is plenty

Dependencies are a natural part of building software, but we aim to minimize them when possible to keep this open-source codebase easy to understand, maintain, and contribute to.

- Push Django to its limits before adding new dependencies
- When a new dependency is added, there must be a strong technical or business reason to add it
- When adding dependencies, you should favor old and reliable over new and flashy 

### Convention 2: Leverage model methods and service classes over "service objects"

This codebase adopts a "skinny views, fat models" convention. Business logic primarily lives in model methods and service classes organized within each Django app.

- Organize complex business logic into service classes in `maybe_django/*/services/` directories
- While a service class may offer shared functionality, it can also be a "one-off" service that is only used in one place for better organization and readability
- When services are used for code organization, they should be organized around the "traits" or "operations" of a domain model
- When possible, models should answer questions about themselvesâ€”for example, we might have a method, `account.get_balance_series()` that returns a time-series of the account's most recent balances.  We prefer this over something more service-like such as `BalanceService.get_series(account)`.

### Convention 3: Leverage HTMX, write semantic HTML, CSS, and JS, prefer server-side solutions

- Native HTML is always preferred over JS-based components
  - Example 1: Use `<dialog>` element for modals instead of creating a custom component
  - Example 2: Use `<details><summary>...</summary></details>` for disclosures rather than custom components
- Leverage HTMX to break up the page over JS-driven client-side solutions
  - Example: Use HTMX attributes (`hx-get`, `hx-post`, `hx-swap`) for dynamic content loading
  - Use HTMX to replace page sections with server-rendered HTML
- Leverage query params in the URL for state over local storage and sessions.  If absolutely necessary, utilize the DB for persistent state.
- Format currencies, numbers, dates, and other values server-side, then pass to templates for display only
- Keep client-side code for where it truly shines.  For example, bulk selection interfaces may require JavaScript for a good user experience. When bulk-selecting entries, client-side solutions are the way to go.
- Use django-components for reusable UI components. Components should live in `maybe_django/*/components/` or similar structure if using django-components directory organization.

The HTMX approach works very well with these native elements and we optimize for this.

### Convention 4: Optimize for simplicity and clarity

All code should maximize readability and simplicity.

- Prioritize good OOP domain design over performance
- Only focus on performance for critical and global areas of the codebase; otherwise, don't sweat the small stuff.
  - Example 1: be mindful of loading large data payloads in global templates
  - Example 2: Avoid N+1 queries using `select_related()` and `prefetch_related()`

### Convention 5: Use Django ORM for complex validations, DB for simple ones, keep business logic in models

- Enforce `null` checks, unique constraints, and other simple validations in the DB via model field definitions
- Django model validations _may_ mirror the DB level ones, but not 100% necessary.  These are for convenience when error handling in forms.  Always prefer client-side form validation when possible.
- Complex validations and business logic should remain in Django models (via `clean()` method or model methods)
