---
description: This rule explains the system architecture and data flow of the Django app
globs: *
alwaysApply: true
---

This file outlines how the codebase is structured and how data flows through the app.

This is a personal finance application built in Django. The primary domain entities for this app are outlined below. For an authoritative overview of the relationships, see the Django model files in `maybe_django/*/models.py`.

## App Architecture

The Maybe Django app is a single-user personal finance application optimized for Brazil. It does not support multi-tenancy.

## Users

- `User` - extends Django's `AbstractUser` and stores all user preferences at the user level. A user has many financial accounts and manages their own finances independently.

## Currency Preference

Each `User` has a `currency` preference (defaults to `BRL`). This becomes the "main" currency in which all records are stored. The app can handle multi-currency transactions but normalizes everything to the user's preferred currency.

## Accounts

The center of the app's domain is the `Account` model. This represents a single financial account that has a `balance` and `currency`. For example, an `Account` could be "Nubank Checking", which is a single financial account at Nubank Bank. A user could have multiple accounts at a single institution or standalone accounts.

### Account Types

Each account has an `accountable_type` which determines its classification and behavior:

- Asset accountables
  - `depository` - a typical "bank account" such as a savings or checking account
  - `investment` - an account that has "holdings" such as a brokerage, 401k, etc.
  - `crypto` - an account that tracks the value of one or more crypto holdings
  - `property` - an account that tracks the value of a physical property such as a house or rental property
  - `vehicle` - an account that tracks the value of a vehicle
  - `other_asset` - an asset that cannot be classified by the other account types
- Liability accountables
  - `credit_card` - an account that tracks the debt owed on a credit card
  - `loan` - an account that tracks the debt owed on a loan (i.e. mortgage, student loan)
  - `other_liability` - a liability that cannot be classified by the other account types

### Account Balances

An account `Balance` represents a single balance value for an account on a specific `date`. A series of balance records is generated daily for each account and is how we show a user's historical balance graph.

- For simple accounts like a "Checking Account", the balance represents the amount of cash in the account for a date.
- For a more complex account like "Investment Brokerage", the `balance` represents the combination of the "cash balance" + "holdings value". Each account type has different components that make up the "balance", but in all cases, the "balance" represents "How much the account is worth" (when `classification` is `asset`) or "How much is owed on the account" (when `classification` is `liability`)

All balances are calculated daily by `BalanceMaterializer` and `BalanceCalculator` services.

### Account Holdings

An account `Holding` applies to `investment` type accounts and represents a `qty` of a certain `Security` at a specific `price` on a specific `date`.

For investment accounts with holdings, holding calculations are done during balance calculation, which are then rolled up into a final "Balance" for the account.

### Account Entries

There are several types of records that _modify_ an `Account` balance and/or holdings:

- `Transaction` - the most common type of entry. Represents an "income" or "expense" that alters the account balance by the `amount`.
- `Valuation` - an entry that says, "here is the value of this account on this date". It is an absolute measure of an account value / debt.
- `Trade` - an entry that only applies to an investment account. This represents a "buy" or "sell" of a holding and has a `qty` and `price`.

### Account Transfers

A `Transfer` represents a movement of money between two accounts. A transfer has an inflow `Transaction` and an outflow `Transaction`. The Maybe system auto-matches transfers based on the following criteria:

- Must be from different accounts
- Must be within 4 days of each other
- Must be the same currency
- Must be opposite values

There are two primary forms of a transfer:

- Regular transfer - a normal movement of money between two accounts
- Debt payment - a special form of transfer where the _receiver_ of funds is a `loan` type account

Regular transfers are typically _excluded_ from income and expense calculations while a debt payment is considered an "expense".

## Import System

The app supports importing financial data via:

1. **OFX Import** - for Brazilian bank OFX files
   - `Import` model manages import sessions
   - OFX files are parsed and transformed into internal Maybe models
   - Supports transaction and balance imports

2. **CSV Import** - manual data import with mapping
   - Custom field mapping with transformation rules
   - Flexible format support

## "Syncs"

The Maybe app has the concept of account syncing, which represents the process of keeping account data up-to-date. An account "sync" performs several important tasks:

- Auto-matches transfer records for the account
- Calculates daily `Balance` records for the account using `BalanceMaterializer` and `BalanceCalculator`
  - Balances are dependent on the calculation of `Holding` records for investment accounts
- Updates account metadata

An account sync happens every time a `Transaction`, `Valuation`, or `Trade` is updated, triggered via Django signals.

### Account Syncs

The account sync is orchestrated by the `AccountSyncer` service class:

1. Creates a `BalanceMaterializer` with the appropriate strategy ('forward' for manual accounts)
2. The materializer uses a `BalanceCalculator` to calculate balances
3. Calculated balances are persisted to the database
4. Stale balances are purged

Account syncs can be triggered:
- Automatically via Django signals when entries change
- Manually by calling `AccountSyncer(account).sync()`
- Asynchronously via Celery tasks (future enhancement)

## Data Providers

The Maybe Django app utilizes 3rd party data services for market data:

- **B3 Price Data**: Fetches security prices from Brazilian stock market (B3) via yfinance
  - Used in `investments/services/b3_price_fetcher.py`
  - Fetches daily prices for securities

## Services Architecture

Business logic is organized into service classes within each Django app's `services/` directory:

- `finance/services/account_syncer.py` - Orchestrates account synchronization
- `finance/services/balance_calculator.py` - Calculates daily balances
- `finance/services/balance_materializer.py` - Materializes (persists) calculated balances
- `finance/services/transfer_matcher.py` - Auto-matches transfers between accounts
- `finance/services/installment_generator.py` - Generates installment transactions for credit card purchases
- `imports/services/ofx_parser.py` - Parses OFX bank files
- `imports/services/csv_parser.py` - Parses CSV import files
- `investments/services/b3_price_fetcher.py` - Fetches B3 market data

Service classes follow a pattern where they:
- Accept domain models as constructor parameters
- Expose simple public methods
- Handle their own transaction boundaries when needed
- Can be easily tested in isolation

## Background Processing

Celery handles asynchronous tasks:

- Investment price fetching (B3 market data)
- Scheduled tasks via Celery Beat
- Account syncing (future enhancement for large accounts)

## Models Structure

Django apps are organized as follows:

- `core/` - User authentication and core models (User)
- `finance/` - Accounts, transactions, balances, categories, rules, budgets
- `investments/` - Securities, holdings, trades, price data
- `imports/` - Import sessions, OFX/CSV parsing

Each app follows Django conventions:
- `models.py` - Domain models
- `views.py` - View functions/classes
- `urls.py` - URL routing
- `admin.py` - Django admin configuration
- `forms.py` - Django forms (when needed)
- `services/` - Business logic services
- `tests.py` - Test cases

## Templates Structure

Templates are organized as follows:

- `maybe_django/templates/base.html` - Base template with navigation
- `maybe_django/templates/core/` - Core app templates (dashboard, register)
- `maybe_django/templates/finance/` - Finance app templates
- `maybe_django/templates/investments/` - Investments app templates
- `maybe_django/templates/imports/` - Imports app templates
- `maybe_django/templates/partials/` - Reusable template partials (e.g., `form_errors.html`)
- `maybe_django/templates/errors/` - Error page templates (404, 500, 403)

## Static Files Structure

- `maybe_django/static/css/input.css` - Tailwind input file with design tokens and component classes
- `maybe_django/static/css/main.css` - Compiled CSS (generated via `npm run css:build`)
