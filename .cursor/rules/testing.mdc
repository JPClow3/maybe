---
description: Guidelines for writing tests using Django's unittest framework
globs: maybe_django/**/tests.py
alwaysApply: false
---
Use this rule to learn how to write tests for the Maybe codebase.

Due to the open-source nature of this project, we have chosen Django's built-in unittest framework for testing to maximize familiarity and predictability.

- **General testing rules**
  - Always use Django's unittest framework, NEVER pytest or other testing frameworks
  - Create test data on-the-fly within test methods
  - For tests that require a large number of records, use Django model factories or helper methods within the test file

- **Write minimal, effective tests**
  - Only write tests for critical and important code paths
  - Write tests as you go, when required
  - Take a practical approach to testing. Tests are effective when their presence _significantly increases confidence in the codebase_.

  Below are examples of necessary vs. unnecessary tests:

  ```python
  # GOOD!!
  # Necessary test - in this case, we're testing critical domain business logic
  def test_syncs_balances(self):
      account = Account.objects.create(
          user=self.user,
          name="Test Account",
          accountable_type='depository',
          currency='BRL'
      )
      Transaction.objects.create(
          account=account,
          date=date.today(),
          amount=Decimal('100.00'),
          currency='BRL'
      )
      
      syncer = AccountSyncer(account)
      syncer.sync()
      
      self.assertEqual(account.balances.count(), 1)
      balance = account.balances.first()
      self.assertEqual(balance.balance, Decimal('100.00'))

  # BAD!!
  # Unnecessary test - in this case, this is simply testing Django ORM functionality
  def test_saves_account(self): 
      account = Account(
          user=self.user,
          name="Test Account",
          accountable_type='depository'
      )
      account.save()
      self.assertIsNotNone(account.id)
  ```

- **Test boundaries correctly**
  - Distinguish between commands and query methods. Test output of query methods; test that commands were called with the correct params. See an example below:

  ```python
  class ExampleService:
      def do_something(self):
          result = 2 + 2
          CustomEventProcessor.process_result(result)
          return result

  class ExampleServiceTestCase(TestCase):
      def test_boundaries_are_tested_correctly(self):
          with patch('example_module.CustomEventProcessor.process_result') as mock_process:
              service = ExampleService()
              result = service.do_something()

              # GOOD - we're only testing that the command was received, not internal implementation details
              # The actual tests for CustomEventProcessor belong in a different test suite!
              mock_process.assert_called_once_with(4)

              # GOOD - we're testing the implementation of ExampleService inside its own test suite
              self.assertEqual(result, 4)
  ```

  - Never test the implementation details of one class in another class's test suite

- **Stubs and mocks**
  - Use Python's `unittest.mock` module
  - Prefer `Mock` or `MagicMock` for mock instances
  - Only mock what's necessary
