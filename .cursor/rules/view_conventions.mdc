---
description: Guidelines for writing Django templates and using django-components
globs: maybe_django/**/*.html
alwaysApply: false
---
Use this rule to learn how to write Django templates and django-components.

- **Component vs. Template Decision Making**
  - **Use django-components when:**
    - Element has complex logic or styling patterns
    - Element will be reused across multiple views/contexts
    - Element needs structured styling with variants/sizes (like buttons, badges)
    - Element requires interactive behavior or HTMX attributes
    - Element has configurable slots or complex APIs
    - Element needs accessibility features or ARIA support
  
  - **Use regular Django templates/partials when:**
    - Element is primarily static HTML with minimal logic
    - Element is used in only one or few specific contexts
    - Element is simple template content (like static sections)
    - Element doesn't need variants, sizes, or complex configuration
    - Element is more about content organization than reusable functionality

- **Prefer components over partials**
  - If there is a django-component available for the use case, use it
  - If there is no component, look for a template partial (included template)
  - If there is no partial, decide between component or partial based on the criteria above

- **Examples of Component vs. Template Usage**
  ```django
  {%# Component: Complex, reusable with variants and interactivity %}
  {% component "button" variant="primary" size="large" %}
    Save Changes
  {% endcomponent %}
  
  {%# Component: Interactive with complex styling options %}
  {% component "dialog" variant="drawer" %}
    {% fill "header" %}
      Account Settings
    {% endfill %}
    {% fill "body" %}
      Dialog content here
    {% endfill %}
  {% endcomponent %}
  
  {%# Template partial: Static template content %}
  {% include "shared/logo.html" %}
  
  {%# Template partial: Simple, context-specific content %}
  {% include "shared/trend_change.html" with trend=account.trend comparison_label="vs last month" %}
  ```

- **Keep domain logic out of the views**
   ```django
    {%# BAD!!! %}
    {%# This belongs in the view or model method, not the template! %}
    {% if account.balance > 1000 %}
      <div class="bg-green-500">High balance</div>
    {% endif %}

    {%# GOOD! %}
    {%# Logic in view: %}
    {# view.py: context['account_status'] = account.get_status_display() #}
    <div class="{{ account_status_classes }}">
      {{ account.get_status_display }}
    </div>
   ```

- **HTMX Integration in Templates**
  - Always use the **declarative approach** when integrating HTMX
  - The Django template should declare what happens with HTMX attributes, the server renders the response
  - Refer to [stimulus_conventions.mdc](mdc:.cursor/rules/stimulus_conventions.mdc) for HTMX conventions and patterns

  GOOD HTMX integration into templates:

  ```django
  {%# Declarative - HTML declares what happens %}
  <div hx-get="/api/accounts/" hx-trigger="load" hx-swap="innerHTML">
    Loading accounts...
  </div>
  ```

- **Naming Conventions**
  - **Components**: Use snake_case names in component directories
  - **Template partials**: No underscore prefix needed - place in `maybe_django/templates/partials/` directory (e.g., `form_errors.html`)
  - **Shared partials**: Place in `maybe_django/templates/partials/` directory for reusable content
  - **Context-specific partials**: Place in relevant app template directory (e.g., `maybe_django/templates/finance/account_form_partial.html`)

- **Django Template Best Practices**
  - Use template tags and filters for reusable logic
  - Use `{% include %}` for template partials
  - Use template inheritance with `{% extends %}` for layouts
  - Keep templates DRY by extracting common patterns
